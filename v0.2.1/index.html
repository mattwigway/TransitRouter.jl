<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TransitRouter.jl · TransitRouter.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TransitRouter.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>TransitRouter.jl</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="raptor/">RAPTOR</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>TransitRouter.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TransitRouter.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mattwigway/TransitRouter.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TransitRouter.jl"><a class="docs-heading-anchor" href="#TransitRouter.jl">TransitRouter.jl</a><a id="TransitRouter.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TransitRouter.jl" title="Permalink"></a></h1><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><h3 id="Build-a-network"><a class="docs-heading-anchor" href="#Build-a-network">Build a network</a><a id="Build-a-network-1"></a><a class="docs-heading-anchor-permalink" href="#Build-a-network" title="Permalink"></a></h3><p>From the command line:</p><pre><code class="nohighlight hljs">julia build_network.jl out_network.trjl in_gtfs [in_gtfs...]</code></pre><p>From Julia:</p><pre><code class="language-julia hljs">network::TransitNetwork = build_network([gtfs_file, ...])

# save the network for later use
save_network(network, filename)</code></pre><p>The <code>--max-transfer-distance</code> option sets the maximum distance, in meters, that will be allowed for transfer between stops (default 1km).</p><h3 id="Routing"><a class="docs-heading-anchor" href="#Routing">Routing</a><a id="Routing-1"></a><a class="docs-heading-anchor-permalink" href="#Routing" title="Permalink"></a></h3><pre><code class="language-julia hljs">network::TransitNetwork = load_network(network_filename)

raptor_request = RaptorRequest(
    # These are stops where you could board transit, and what time you could board there. Multiple can be specified,
    # for instance if an external street router were used to get the travel times to a number of nearby stops
    # stop_idx is a numerical index. It can be retrieved from stop IDs using network.stopidx_for_id[&quot;filename:stop_id&quot;]
    # note that stop_ids are prefixed with the path of the GTFS file they came from, as specified on the command line
    # or in the arguments to build_network
    [
        StopAndTime(stop_idx::Int64, time_seconds_since_midnight::Int32),
        ...
    ],
    4, # maximum number of rides, e.g. 4 = max 3 transfers
    Date(&quot;2021-04-13&quot;, &quot;yyyy-mm-dd&quot;), # date of search
    1.33 # walk speed in meters per second
)

raptor_result = raptor(network, raptor_request)</code></pre><p><code>raptor_result</code> has a number of arrays. The most interesting one is <code>times_at_stops_each_round</code>; each row represents the result of a RAPTOR round, with the fastest travel time to that stop found in that round (or before that round). It is longer than the number of rounds, because Round 1 is considered the street search and is initialized based on the request, and then each RAPTOR round results in two rows—one for stops reached via transit, and then an additional &quot;transfers&quot; round.</p><h3 id="Extracting-paths"><a class="docs-heading-anchor" href="#Extracting-paths">Extracting paths</a><a id="Extracting-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-paths" title="Permalink"></a></h3><p>With a <code>RaptorResult</code> (or a <code>StreetRaptorResult</code>, described below), you can call <code>trace_path(result, stop)</code> (or <code>trace_path(result, destination)</code> in the <code>StreetRaptorResult</code> context). This will return a vector of <code>Leg</code>s which have members <code>start_time</code>, <code>end_time</code>, <code>origin_stop</code>, <code>destination_stop</code>, <code>type</code> (<code>LegType</code> enum member, <code>transit</code> or <code>transfer</code>), and <code>route</code>. <code>origin_stop</code>, <code>destination_stop</code>, and <code>route</code> are all indexes into <code>network.stops</code> or <code>network.routes</code> if you need to derive more information.</p><h3 id="Street-routing"><a class="docs-heading-anchor" href="#Street-routing">Street routing</a><a id="Street-routing-1"></a><a class="docs-heading-anchor-permalink" href="#Street-routing" title="Permalink"></a></h3><p>Transit network routing is most usefully combined with street routing, because access, egress, and (most) transfers occur on the street network. Rather than implement a complete street router, TransitRouter.jl uses <a href="http://project-osrm.org">OSRM</a> (Luxen and Vetter, 2011) to provide street routing, and uses Julia&#39;s <code>ccall</code> functionality to call OSRM. Since OSRM is written in C++, TransitRouter.jl includes a very small C++ shim around OSRM with <code>extern &quot;C&quot;</code> functions to initialize, route, and shut down an OSRM routing engine. The code for this is in the <code>cxx</code> folder of this repository. </p><p>Street routing is entirely optional, and TransitRouter.jl will function just fine without it. Configuring street routing requires a few additional steps, described below.</p><h4 id="Building-and-installing-the-C-shim"><a class="docs-heading-anchor" href="#Building-and-installing-the-C-shim">Building and installing the C++ shim</a><a id="Building-and-installing-the-C-shim-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-installing-the-C-shim" title="Permalink"></a></h4><p>The OSRM interface relies on a shared library <code>libosrmjl.so</code> (<code>libosrmjl.dylib</code> on Mac) which contains a shim around OSRM, and is built from the code in the <code>cxx</code> folder. Before you can build <code>libosrmjl</code>, you need to have <a href="https://github.com/Project-OSRM/osrm-backend">osrm-backend</a> installed, with <code>libosrm.so</code>, <code>libosrm.dylib</code>, or <code>libosrm.a</code> somewhere in your library path. This may require building <code>osrm-backend</code> from source.</p><p>Once <code>osrm-backend</code> is installed, in the <code>cxx/build</code> directory, run <code>cmake ..</code> then <code>cmake --build .</code>. If all goes well, there will be no errors, and this will create a file called <code>libosrm.so</code> or <code>libosrm.dylib</code> in the build directory. In order for TransitRouter.jl to find this library, it either needs to be moved into a system-wide library directory (e.g. <code>/usr/local/lib</code>) or Julia needs to be run with the path to the <code>cxx/build</code> in the environment variable <code>LD_LIBRARY_PATH</code> (e.g. <code>&quot;LD_LIBRARY_PATH=~/TransitRouter.jl/cxx/build/:$LD_LIBRARY_PATH&quot;&quot; julia ...</code>).</p><h4 id="Building-a-street-network"><a class="docs-heading-anchor" href="#Building-a-street-network">Building a street network</a><a id="Building-a-street-network-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-street-network" title="Permalink"></a></h4><p>Since TransitRouter.jl calls out to OSRM for street routing, an OSRM network will need to be built in order to use street routing. An OSRM network should be prepared using the normal tools from the OSRM project. Instructions for preparing a <code>.osrm</code> file from an OpenStreetMap extract of the area in question are found in <a href="https://github.com/Project-OSRM/osrm-backend#quick-start">OSRM&#39;s quick start documentation</a>. The documentation describes using OSRM in Docker, but using OSRM within TransitRouter.jl requires OSRM be installed locally. The instructions translate well if you just remove <code>docker run -t -v &quot;${PWD}:/data&quot; osrm/osrm-backend</code> from the start of commands, and pass paths on the local file system.</p><p>For instance, to build an OSRM network for Southern California using multi-level Dijkstra for use in walk routing, you would run:</p><pre><code class="nohighlight hljs">osrm-extract -p /usr/local/share/osrm/profiles/foot.lua socal-latest.osm.pbf
osrm-partition socal-latest.osrm
osrm-customize socal-latest.osrm</code></pre><h4 id="Performing-street-transit-routing"><a class="docs-heading-anchor" href="#Performing-street-transit-routing">Performing street + transit routing</a><a id="Performing-street-transit-routing-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-street-transit-routing" title="Permalink"></a></h4><p>Street + transit routing is done a little bit differently than transit only routing, as the following example demonstrates. Rather than being stop-based, it is origin-destination based. Note that street + transit routing always requires a transit ride, so travel times to areas very close to the origin (where one would normally just walk) may seem quite high.</p><pre><code class="language-julia hljs">using TransitRouter
using TransitRouter.OSRM

network = load_network(&quot;path/to/network.trjl&quot;)
osrm = start_osrm(&quot;path/to/osrm/network.osrm&quot;)

# somehow get a vector of TransitRouter.OSRM.Coordinate to use as your destinations
# could come from a CSV, JuliaGeo object, etc.
# coordinates are lat, lon WGS84
destinations = [
    Coordinate(34.108624, -118.152524), # South Pasadena
    Coordinate(34.056828, -118.246004), # DTLA
    Coordinate(34.050271, -118.421021)  # Century City
]

# this caches the travel times from stops to your destinations
# with a large number of destinations, this will be slow, but the resulting
# object can be re-used for multiple origins
# max_egress_distance_meters is the limit on how far you allow egressing from transit
# (for example, not walking more than 2km after alighting)
# the osrm parameter here is used for egressing from transit
cached_egress_times = find_egress_times(network, osrm, destinations, max_egress_distance_meters)

# perform street + transit routing from a single origin to all destinations
street_raptor_request = StreetRaptorRequest(
    StreetRaptorRequest(
        Coordinate(33.938471, -118.242011),  # Origin
        25200,                               # Departure time from origin, seconds since midnight
        Date(2018, 01, 08),                  # Date
        2000,                                # Maximum access distance to first boarding, meters
        1.33,                                # Walk speed for transfers, meters/second 
                                             # (the user is responsible for making this comparable
                                             #    to the speeds used in OSRM)
        4                                    # Maximum number of transit rides
    )
)

# run the request. the osrm parameter here is used for the access portion of the search. it can
# differ from the osrm parameter used in find_egress_times, for instance for a drive-to-transit
# search where a driving osrm network would be used here, and a walking network used for egress
# (this is the -p option to osrm-extract, see
#   https://github.com/Project-OSRM/osrm-backend/blob/master/docs/profiles.md)
street_raptor_result = street_raptor(network, osrm, street_raptor_request, cached_egress_times)

# this frees the memory used by the OSRM server, which is allocated outside the purview of the
# Julia garbage collector.
stop_osrm!(osrm)</code></pre><p><code>street_raptor_result</code> contains an array <code>times_at_destinations</code>, the original <code>request</code>, the <code>raptor_result</code> from the transit portion of the search, and <code>egress_stop_for_destination</code> which records which stop was used to get to the destination.</p><p>As with a <code>RaptorResult</code>, you can run <code>trace_path(street_raptor_result, destination_index)</code> and get a list of the legs used to get to the destination <code>destination_index</code> (note that unlike when tracing a <code>RaptorResult</code>, this is a destination index, not a stop index). The output will be identical to tracing a <code>RaptorResult</code>, but will include <code>access</code> and <code>egress</code> legs.</p><h4 id="Using-the-street-network-for-transfers"><a class="docs-heading-anchor" href="#Using-the-street-network-for-transfers">Using the street network for transfers</a><a id="Using-the-street-network-for-transfers-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-street-network-for-transfers" title="Permalink"></a></h4><p>Transfer distances are precomputed when the network is built. By default they are based on straight-line differences, but by passing a <code>-n path/to/osrm/network.osrm</code> option to <code>build_network.jl</code>, or calling <code>build_network()</code> with a second parameter that is an OSRM object created <code>start_osrm</code>, OSRM will be used to compute network distances for transfers.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>Delling, D., Pajor, T., &amp; Werneck, R. (2012). Round-Based Public Transit Routing. http://research.microsoft.com/pubs/156567/raptor_alenex.pdf</p><p>Luxen, D., &amp; Vetter, C. (2011). Real-time routing with OpenStreetMap data. Proceedings of the 19th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems - GIS ’11, 513. https://doi.org/10.1145/2093973.2094062</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="raptor/">RAPTOR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 18 September 2023 18:53">Monday 18 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
